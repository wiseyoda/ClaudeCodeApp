//
// ServerMessage.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public enum ServerMessage: Sendable, Codable, Hashable {
    case typeConnectedMessage(ConnectedMessage)
    case typeCursorEvictedMessage(CursorEvictedMessage)
    case typeCursorInvalidMessage(CursorInvalidMessage)
    case typeErrorMessage(ErrorMessage)
    case typeHistoryMessage(HistoryMessage)
    case typeInterruptedMessage(InterruptedMessage)
    case typeModelChangedMessage(ModelChangedMessage)
    case typePermissionModeChangedMessage(PermissionModeChangedMessage)
    case typePermissionRequestMessage(PermissionRequestMessage)
    case typePongMessage(PongMessage)
    case typeQuestionMessage(QuestionMessage)
    case typeQueueClearedMessage(QueueClearedMessage)
    case typeQueuedMessage(QueuedMessage)
    case typeReconnectCompleteMessage(ReconnectCompleteMessage)
    case typeServerPingMessage(ServerPingMessage)
    case typeSessionEventMessage(SessionEventMessage)
    case typeStoppedMessage(StoppedMessage)
    case typeStreamServerMessage(StreamServerMessage)

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .typeConnectedMessage(let value):
            try container.encode(value)
        case .typeCursorEvictedMessage(let value):
            try container.encode(value)
        case .typeCursorInvalidMessage(let value):
            try container.encode(value)
        case .typeErrorMessage(let value):
            try container.encode(value)
        case .typeHistoryMessage(let value):
            try container.encode(value)
        case .typeInterruptedMessage(let value):
            try container.encode(value)
        case .typeModelChangedMessage(let value):
            try container.encode(value)
        case .typePermissionModeChangedMessage(let value):
            try container.encode(value)
        case .typePermissionRequestMessage(let value):
            try container.encode(value)
        case .typePongMessage(let value):
            try container.encode(value)
        case .typeQuestionMessage(let value):
            try container.encode(value)
        case .typeQueueClearedMessage(let value):
            try container.encode(value)
        case .typeQueuedMessage(let value):
            try container.encode(value)
        case .typeReconnectCompleteMessage(let value):
            try container.encode(value)
        case .typeServerPingMessage(let value):
            try container.encode(value)
        case .typeSessionEventMessage(let value):
            try container.encode(value)
        case .typeStoppedMessage(let value):
            try container.encode(value)
        case .typeStreamServerMessage(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(ConnectedMessage.self) {
            self = .typeConnectedMessage(value)
        } else if let value = try? container.decode(CursorEvictedMessage.self) {
            self = .typeCursorEvictedMessage(value)
        } else if let value = try? container.decode(CursorInvalidMessage.self) {
            self = .typeCursorInvalidMessage(value)
        } else if let value = try? container.decode(ErrorMessage.self) {
            self = .typeErrorMessage(value)
        } else if let value = try? container.decode(HistoryMessage.self) {
            self = .typeHistoryMessage(value)
        } else if let value = try? container.decode(InterruptedMessage.self) {
            self = .typeInterruptedMessage(value)
        } else if let value = try? container.decode(ModelChangedMessage.self) {
            self = .typeModelChangedMessage(value)
        } else if let value = try? container.decode(PermissionModeChangedMessage.self) {
            self = .typePermissionModeChangedMessage(value)
        } else if let value = try? container.decode(PermissionRequestMessage.self) {
            self = .typePermissionRequestMessage(value)
        } else if let value = try? container.decode(PongMessage.self) {
            self = .typePongMessage(value)
        } else if let value = try? container.decode(QuestionMessage.self) {
            self = .typeQuestionMessage(value)
        } else if let value = try? container.decode(QueueClearedMessage.self) {
            self = .typeQueueClearedMessage(value)
        } else if let value = try? container.decode(QueuedMessage.self) {
            self = .typeQueuedMessage(value)
        } else if let value = try? container.decode(ReconnectCompleteMessage.self) {
            self = .typeReconnectCompleteMessage(value)
        } else if let value = try? container.decode(ServerPingMessage.self) {
            self = .typeServerPingMessage(value)
        } else if let value = try? container.decode(SessionEventMessage.self) {
            self = .typeSessionEventMessage(value)
        } else if let value = try? container.decode(StoppedMessage.self) {
            self = .typeStoppedMessage(value)
        } else if let value = try? container.decode(StreamServerMessage.self) {
            self = .typeStreamServerMessage(value)
        } else {
            throw DecodingError.typeMismatch(Self.Type.self, .init(codingPath: decoder.codingPath, debugDescription: "Unable to decode instance of ServerMessage"))
        }
    }
}


