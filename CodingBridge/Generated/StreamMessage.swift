//
// StreamMessage.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public enum StreamMessage: Sendable, Codable, Hashable {
    case typeAssistantStreamMessage(AssistantStreamMessage)
    case typeProgressStreamMessage(ProgressStreamMessage)
    case typeStateStreamMessage(StateStreamMessage)
    case typeSubagentCompleteStreamMessage(SubagentCompleteStreamMessage)
    case typeSubagentStartStreamMessage(SubagentStartStreamMessage)
    case typeSystemStreamMessage(SystemStreamMessage)
    case typeToolResultStreamMessage(ToolResultStreamMessage)
    case typeToolUseStreamMessage(ToolUseStreamMessage)
    case typeUsageStreamMessage(UsageStreamMessage)
    case typeUserStreamMessage(UserStreamMessage)

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .typeAssistantStreamMessage(let value):
            try container.encode(value)
        case .typeProgressStreamMessage(let value):
            try container.encode(value)
        case .typeStateStreamMessage(let value):
            try container.encode(value)
        case .typeSubagentCompleteStreamMessage(let value):
            try container.encode(value)
        case .typeSubagentStartStreamMessage(let value):
            try container.encode(value)
        case .typeSystemStreamMessage(let value):
            try container.encode(value)
        case .typeToolResultStreamMessage(let value):
            try container.encode(value)
        case .typeToolUseStreamMessage(let value):
            try container.encode(value)
        case .typeUsageStreamMessage(let value):
            try container.encode(value)
        case .typeUserStreamMessage(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(AssistantStreamMessage.self) {
            self = .typeAssistantStreamMessage(value)
        } else if let value = try? container.decode(ProgressStreamMessage.self) {
            self = .typeProgressStreamMessage(value)
        } else if let value = try? container.decode(StateStreamMessage.self) {
            self = .typeStateStreamMessage(value)
        } else if let value = try? container.decode(SubagentCompleteStreamMessage.self) {
            self = .typeSubagentCompleteStreamMessage(value)
        } else if let value = try? container.decode(SubagentStartStreamMessage.self) {
            self = .typeSubagentStartStreamMessage(value)
        } else if let value = try? container.decode(SystemStreamMessage.self) {
            self = .typeSystemStreamMessage(value)
        } else if let value = try? container.decode(ToolResultStreamMessage.self) {
            self = .typeToolResultStreamMessage(value)
        } else if let value = try? container.decode(ToolUseStreamMessage.self) {
            self = .typeToolUseStreamMessage(value)
        } else if let value = try? container.decode(UsageStreamMessage.self) {
            self = .typeUsageStreamMessage(value)
        } else if let value = try? container.decode(UserStreamMessage.self) {
            self = .typeUserStreamMessage(value)
        } else {
            throw DecodingError.typeMismatch(Self.Type.self, .init(codingPath: decoder.codingPath, debugDescription: "Unable to decode instance of StreamMessage"))
        }
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension StreamMessage: Identifiable {}
