//
// UsageStreamMessage.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct UsageStreamMessage: Sendable, Codable, Hashable {

    public enum ModelType: String, Sendable, Codable, CaseIterable {
        case usage = "usage"
    }
    public var type: ModelType
    /** Input token count */
    public var inputTokens: Int
    /** Output token count */
    public var outputTokens: Int
    /** Tokens served from cache */
    public var cacheReadTokens: Int?
    /** Tokens written to cache */
    public var cacheCreateTokens: Int?
    /** Estimated cost */
    public var totalCost: Double?
    /** Cumulative tokens in context */
    public var contextUsed: Int?
    /** Max context window */
    public var contextLimit: Int?

    public init(type: ModelType, inputTokens: Int, outputTokens: Int, cacheReadTokens: Int? = nil, cacheCreateTokens: Int? = nil, totalCost: Double? = nil, contextUsed: Int? = nil, contextLimit: Int? = nil) {
        self.type = type
        self.inputTokens = inputTokens
        self.outputTokens = outputTokens
        self.cacheReadTokens = cacheReadTokens
        self.cacheCreateTokens = cacheCreateTokens
        self.totalCost = totalCost
        self.contextUsed = contextUsed
        self.contextLimit = contextLimit
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case type
        case inputTokens
        case outputTokens
        case cacheReadTokens
        case cacheCreateTokens
        case totalCost
        case contextUsed
        case contextLimit
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(type, forKey: .type)
        try container.encode(inputTokens, forKey: .inputTokens)
        try container.encode(outputTokens, forKey: .outputTokens)
        try container.encodeIfPresent(cacheReadTokens, forKey: .cacheReadTokens)
        try container.encodeIfPresent(cacheCreateTokens, forKey: .cacheCreateTokens)
        try container.encodeIfPresent(totalCost, forKey: .totalCost)
        try container.encodeIfPresent(contextUsed, forKey: .contextUsed)
        try container.encodeIfPresent(contextLimit, forKey: .contextLimit)
    }
}

